{"version":3,"sources":["components/PlanetData.tsx","utils/common.ts","utils/planets.ts","AutoSuggest.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["PlanetDataContainer","styled","div","props","factionColor","PlanetData","planetData","name","sector","region","link","grid","factionData","factionName","colour","type","planetFeatures","climate","terrain","population","hasSubFactions","subFactionData","length","map","faction","keyId","indexOf","className","key","toString","replace","href","fullListOfPlanetNames","planetsGeo","features","x","properties","filter","getDataForPlanetWithName","planet","property","findFactionForPlanetWithName","factionPlanets","find","planets","includes","findSubFactionsForPlanetWithName","factions","featuresOfPlanet","getSuggestions","value","inputValue","trim","toLowerCase","inputLength","slice","getSuggestionValue","suggestion","ResultButton","button","AutoComplete","state","suggestions","renderSuggestion","onClick","setState","onChange","event","newValue","onSuggestionsFetchRequested","onSuggestionsClearRequested","clearPlanetData","this","inputProps","placeholder","id","React","Component","App","displayData","nameOfPlanet","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9af993c5.chunk.js","sourcesContent":["import React from \"react\";\nimport styled from \"styled-components\";\nimport { numberWithCommas } from \"../utils/common\";\n\nconst PlanetDataContainer = styled.div`\n  border-color: white;\n  border-style: solid;\n  border-width: 2px;\n  width: fit-content;\n  padding: 10px;\n  font-size: 0.5em;\n  margin: 10px;\n  h2 {\n    background: ${props => (props.factionColor ? props.factionColor : \"black\")};\n  }\n  a {\n    color: white;\n  }\n  span {\n    font-weight: bold;\n  }\n`;\n\nconst PlanetData = props => {\n  const { name, sector, region, link, grid } = props.planetData;\n  const { factionName, type, colour } = props.factionData;\n  const { climate, terrain, population } = props.planetFeatures;\n\n  const hasSubFactions = props.subFactionData.length > 0;\n\n  return (\n    <PlanetDataContainer factionColor={colour}>\n      <h2>\n        {name} {grid && \"| \" + grid}\n      </h2>\n      {factionName && (\n        <p>\n          <span>Held by:</span> {factionName}\n        </p>\n      )}\n      {hasSubFactions && (\n        <div>\n          <span>Factions represented:</span>\n          <ul>\n            {props.subFactionData.map(faction => {\n              const keyId = props.subFactionData.indexOf(faction);\n              return (\n                <li className=\"sub-faction\" key={keyId}>\n                  {faction.factionName}\n                </li>\n              );\n            })}\n          </ul>\n        </div>\n      )}\n      {sector && (\n        <p>\n          <span>Sector:</span> {sector}\n        </p>\n      )}\n      {region && (\n        <p>\n          <span>Region:</span> {region}\n        </p>\n      )}\n      {population && (\n        <p>\n          <span>Population:</span> {numberWithCommas(population)}\n        </p>\n      )}\n      {climate && (\n        <p>\n          <span>Climate:</span> {climate}\n        </p>\n      )}\n      {terrain && (\n        <p>\n          <span>Terrain:</span> {terrain}\n        </p>\n      )}\n      {link && (\n        <p>\n          <a href={link}>Wookieepedia</a>\n        </p>\n      )}\n    </PlanetDataContainer>\n  );\n};\n\nexport default PlanetData;\n","export const numberWithCommas = num => {\n  return num.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n};\n","import planetsGeo from \"../data/planetsGeo.json\";\nimport factionPlanets from \"../data/factionPlanets.json\";\nimport planets from \"../data/planets.json\";\n\nconst UNKNOWN = \"Unknown\";\n\nconst fullListOfPlanetNames = planetsGeo.features\n  .map(x => x.properties.name)\n  .filter(name => name !== null);\n\nconst getDataForPlanetWithName = (name: string) => {\n  return planetsGeo.features\n    .map(planet => planet.properties)\n    .filter(property => property.name === name)[0];\n};\n\nconst findFactionForPlanetWithName = (name: string) => {\n  const faction = factionPlanets.find(\n    faction => faction.planets.includes(name) && faction.type === \"primary\"\n  );\n  return faction\n    ? { factionName: faction.factionName, colour: faction.colour }\n    : { factionName: \"Unallied\", colour: \"black\" };\n};\n\nconst findSubFactionsForPlanetWithName = (name: string) => {\n  const factions = factionPlanets.filter(\n    faction => faction.planets.includes(name) && faction.type === \"secondary\"\n  );\n  return factions ? factions : [];\n};\n\nconst featuresOfPlanet = (name: string) => {\n  const planet = planets.find(planet => planet.name === name);\n  return planet\n    ? planet\n    : { climate: UNKNOWN, terrain: UNKNOWN, population: UNKNOWN };\n};\n\nexport {\n  getDataForPlanetWithName,\n  fullListOfPlanetNames,\n  findFactionForPlanetWithName,\n  featuresOfPlanet,\n  findSubFactionsForPlanetWithName\n};\n","import React from \"react\";\nimport Autosuggest from \"react-autosuggest\";\nimport PlanetData from \"./components/PlanetData\";\nimport {\n  getDataForPlanetWithName,\n  fullListOfPlanetNames,\n  findFactionForPlanetWithName,\n  featuresOfPlanet,\n  findSubFactionsForPlanetWithName\n} from \"./utils/planets\";\nimport styled from \"styled-components\";\nimport Planet from \"./interfaces/planet\";\n\n// Teach Autosuggest how to calculate suggestions for any given input value.\nconst getSuggestions = (value: string) => {\n  const inputValue = value.trim().toLowerCase();\n  const inputLength = inputValue.length;\n\n  return inputLength === 0\n    ? []\n    : fullListOfPlanetNames.filter(\n        name => name.toLowerCase().slice(0, inputLength) === inputValue\n      );\n};\n\n// When suggestion is clicked, Autosuggest needs to populate the input\n// based on the clicked suggestion. Teach Autosuggest how to calculate the\n// input value for every given suggestion.\nconst getSuggestionValue = suggestion => suggestion;\n\nconst ResultButton = styled.button`\n  font-size: 0.5em;\n  margin: 0.4em;\n  padding: 0.25em 1em;\n  border-radius: 3px;\n  color: white;\n  background-color: #282c34;\n  :hover {\n    background-color: #474b52;\n  }\n`;\n\nexport default class AutoComplete extends React.Component {\n  // Autosuggest is a controlled component.\n  // This means that you need to provide an input value\n  // and an onChange handler that updates this value (see below).\n  // Suggestions also need to be provided to the Autosuggest,\n  // and they are initially empty because the Autosuggest is closed.\n  state = {\n    value: \"\",\n    suggestions: [],\n    planetData: {} as Planet\n  };\n\n  // Use your imagination to render suggestions.\n  renderSuggestion = suggestion => {\n    const planetData: Planet = getDataForPlanetWithName(suggestion);\n    return (\n      <>\n        <ResultButton\n          onClick={() => {\n            this.setState({ planetData: planetData });\n          }}>\n          {suggestion}\n        </ResultButton>\n      </>\n    );\n  };\n\n  onChange = (event, { newValue }) => {\n    this.setState({\n      value: newValue\n    });\n  };\n\n  // Autosuggest will call this function every time you need to update suggestions.\n  // You already implemented this logic above, so just use it.\n  onSuggestionsFetchRequested = ({ value }) => {\n    this.setState({\n      suggestions: getSuggestions(value),\n      planetData: {}\n    });\n  };\n\n  // Autosuggest will call this function every time you need to clear suggestions.\n  onSuggestionsClearRequested = () => {\n    this.setState({\n      suggestions: []\n    });\n  };\n\n  clearPlanetData = () => {\n    this.setState({\n      planetData: {}\n    });\n  };\n\n  render() {\n    const { value, suggestions } = this.state;\n\n    // Autosuggest will pass through all these props to the input.\n    const inputProps = {\n      placeholder: \"Type a planet's name...\",\n      value,\n      onChange: this.onChange\n    };\n\n    // Finally, render it!\n    return (\n      <>\n        <Autosuggest\n          suggestions={suggestions}\n          onSuggestionsFetchRequested={this.onSuggestionsFetchRequested}\n          onSuggestionsClearRequested={this.onSuggestionsClearRequested}\n          getSuggestionValue={getSuggestionValue}\n          renderSuggestion={this.renderSuggestion}\n          inputProps={inputProps}\n        />\n        {this.state.planetData.name && (\n          <div id=\"result\">\n            <PlanetData\n              planetData={this.state.planetData}\n              planetFeatures={featuresOfPlanet(this.state.planetData.name)}\n              factionData={findFactionForPlanetWithName(\n                this.state.planetData.name\n              )}\n              subFactionData={findSubFactionsForPlanetWithName(\n                this.state.planetData.name\n              )}\n            />\n          </div>\n        )}\n      </>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport AutoComplete from \"./AutoSuggest\";\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      planetData: \"\"\n    };\n  }\n\n  displayData = (nameOfPlanet: string) => {\n    this.setState({ planetData: nameOfPlanet });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>Galaxy Map</h1>\n          <>\n            <AutoComplete />\n          </>\n        </header>\n        <div id=\"planetData\"></div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}